#include "test_translation_subroutines.h"

#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdarg.h>
#include "test_common_subroutines.h"
#include "test_framework.h"
#include "../framework/interface.h"
#include "../framework/logger.h"

/**
 *  Function : compare_reference_logs
 *
 *  @brief  Function to compare the log file generated by the test against the 
 *          corresponding reference log
 * 
 *  @return SUCCESS or FAILURE
 * */
static int compare_reference_logs(const char *log_file)
{
#define REF_DIR "reference_logs/"
#define LOG_DIR "logs/"
#define DIFF    "diff -q --speed-large-files --strip-trailing-cr "

    const int filename_len = strlen(log_file);

    char reference_log_path[sizeof REF_DIR + filename_len];
    strcpy(reference_log_path, REF_DIR);
    strcat(reference_log_path, log_file);

    //Only proceed with the compare if the reference log file is found!
    if (access(reference_log_path, F_OK) != -1) {
        char current_log_path[sizeof LOG_DIR + filename_len];
        strcpy(current_log_path, LOG_DIR);
        strcat(current_log_path, log_file);

        char command[sizeof DIFF + sizeof reference_log_path +
                     sizeof current_log_path - 1];
        strcpy(command, DIFF);
        strcat(command, reference_log_path);
        strcat(command, " ");
        strcat(command, current_log_path);

        close_log();

        if (system(command) != 0) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Log file miss-compare detected between %s and %s\n",
                        reference_log_path, current_log_path);
            return FAILURE;
        }
        log_console(LOG_INFO, "", "", __LINE__,
                    "Logfile comparison : Successful\n");
    }
    return SUCCESS;
}

/**
 *  Function : test_translation_user_defined
 *
 *  @brief  Function where the user can write their own test
 *
 *  @return SUCCESS or FAILURE
 * */
int test_translation_user_defined(int data_type, int memory_configuration,
                                  int replacement_policy)
{
    int ret_value = FAILURE;
    char log_filename[MAX_LOG_FILE_NAME_SIZE] = {};
    int ret = run_test_initilization_sequence("translation_user_defined_test",
                                              log_filename, data_type,
                                              memory_configuration, 0);
    if (ret != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "run_test_initilization_sequence Failed!\n");
        goto exit_condition;
    }

    log_console(LOG_INFO, "", "", __LINE__, "TEST START: %s\n", log_filename);
    //------------ START USER DEFINED TEST HERE --------------- //

exit_condition:
    if (ret_value == FAILURE) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "TEST FAILED : %s\n", log_filename);
    } else {
        log_console(LOG_INFO, "", "", __LINE__, "TEST PASSED : %s\n",
                    log_filename);
    }

    return ret_value;
}

int test_tlb_sanity(int memory_configuration, int replacement_policy)
{
    int ret_value = FAILURE;
    int i, address;
    uint8_t read_data, write_data;
    char log_filename[MAX_LOG_FILE_NAME_SIZE] = {};
    if (run_test_initilization_sequence("test_tlb_sanity", log_filename,
                                        BYTE_TYPE, memory_configuration,
                                        replacement_policy) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "run_test_initilization_sequence Failed!\n");
        goto exit_condition;
    }

    log_console(LOG_INFO, "", "", __LINE__, "TEST START: %s\n", log_filename);

    if (allocate_page_addresses(mem_config.max_virtual_pages) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "allocate_page_addresses of %d pages Failed\n",
                    mem_config.max_virtual_pages);
        goto exit_condition;
    }

    //Fill the physical memory with page data. Each address will hold the value of the page no it belongs to.
    if (fill_memory(BYTE_TYPE, FILL_TYPE_PAGE_NO, PHYSICAL_MEMORY) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "Failed to fill physical memory\n");
        goto exit_condition;
    }

    //We should get continuous TLB misses now and the tlb enties should be updated
    for (i = 0; i < mem_config.max_tlb_entries; i++) {
        address = page_address_container[i];
        read_data = 0;
        if (pemmu_read_data(address, (void *) &read_data, BYTE_TYPE_SIZE) !=
            SUCCESS) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "pemmu_read_data failed\n");
            goto exit_condition;
        }
    }

    //These should all be TLB hits!
    for (i = 0; i < mem_config.max_tlb_entries; i++) {
        address = page_address_container[i];
        read_data = 0;
        if (pemmu_read_data(address, (void *) &read_data, BYTE_TYPE_SIZE) !=
            SUCCESS) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "pemmu_read_data failed\n");
            goto exit_condition;
        }
    }

    //Now Write to new addresses to cause page faults
    for (i = 0; i < mem_config.max_tlb_entries; i++) {
        address = page_address_container[i + mem_config.max_physical_pages];
        write_data = i + mem_config.max_physical_pages;
        if (pemmu_write_data(address, (void *) &write_data, BYTE_TYPE_SIZE) !=
            SUCCESS) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "pemmu_write_data failed\n");
            goto exit_condition;
        }
    }

    //Should all be TLB HITS!
    for (i = 0; i < mem_config.max_tlb_entries; i++) {
        address = page_address_container[i + mem_config.max_physical_pages];
        read_data = 0;
        if (pemmu_read_data(address, (void *) &read_data, BYTE_TYPE_SIZE) !=
            SUCCESS) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "pemmu_read_data failed\n");
            goto exit_condition;
        }
        if (read_data != i + mem_config.max_physical_pages) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Data missmatch! Expected: %d | Actual: %d\n",
                        i + mem_config.max_physical_pages, read_data);
            goto exit_condition;
        }
    }

    if (compare_reference_logs(log_filename) != SUCCESS) {
        log_console(LOG_CRITICAL, __FILE__, __FUNCTION__, __LINE__,
                    "Log compare failed! Did not match reference log\n");
        goto exit_condition;
    }

    ret_value = SUCCESS;

exit_condition:
    if (ret_value == FAILURE) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "TEST FAILED : %s\n", log_filename);
    } else {
        log_console(LOG_INFO, "", "", __LINE__, "TEST PASSED : %s\n",
                    log_filename);
    }
    return ret_value;
}

int test_data_access_pattern_fifo(int memory_configuration)
{
    int ret_value = FAILURE;
    int i, j, address, page_no;
    uint8_t read_data, write_data;
    char log_filename[MAX_LOG_FILE_NAME_SIZE] = {};
    if (run_test_initilization_sequence(
            "test_access_pattern_fifo", log_filename, BYTE_TYPE,
            memory_configuration, FIFO_REPLACEMENT_POLICY) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "run_test_initilization_sequence Failed!\n");
        goto exit_condition;
    }

    log_console(LOG_INFO, "", "", __LINE__, "TEST START: %s\n", log_filename);

    if (allocate_page_addresses(mem_config.max_virtual_pages) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "allocate_page_addresses of %d pages Failed\n",
                    mem_config.max_virtual_pages);
        goto exit_condition;
    }

    //Fill the physical memory with page data. Each address will hold the value of the page no it belongs to.
    if (fill_memory(BYTE_TYPE, FILL_TYPE_PAGE_NO, PHYSICAL_MEMORY) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "Failed to fill physical memory\n");
        goto exit_condition;
    }

    //Read the entire physical memory in reverse order
    for (i = 0; i < mem_config.max_physical_pages; i++) {
        page_no = mem_config.max_physical_pages - 1 - i;
        address = page_address_container[page_no];
        for (j = 0; j < mem_config.max_page_entries; j++) {
            if (pemmu_read_data(address, (void *) &read_data, BYTE_TYPE_SIZE) !=
                SUCCESS) {
                log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                            "pemmu_read_data failed\n");
                goto exit_condition;
            }
            if (read_data != page_no) {
                log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                            "Read Data Missmatch. Expected: %d | Actual: %d\n",
                            page_no, read_data);
                goto exit_condition;
            }
            address += BYTE_TYPE_SIZE;
        }
    }

    //Write to (half of the max physical pages) pages. This should cause the first half of the physical pages to be evicted
    for (i = 0; i < mem_config.max_physical_pages / 2; i++) {
        address = page_address_container[mem_config.max_physical_pages + i];
        write_data = (uint32_t) mem_config.max_physical_pages + i;
        if (pemmu_write_data(address, (void *) &write_data, BYTE_TYPE_SIZE) !=
            SUCCESS) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "pemmu_write_data failed\n");
            goto exit_condition;
        }
    }

    //Read the second half of the physical memory and it should still be intact. No evictions
    for (i = mem_config.max_physical_pages / 2;
         i < mem_config.max_physical_pages; i++) {
        address = page_address_container[i];
        if (pemmu_read_data(address, (void *) &read_data, BYTE_TYPE_SIZE) !=
            SUCCESS) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "pemmu_read_data failed\n");
            goto exit_condition;
        }
        if (read_data != i) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Read Data Missmatch. Expected: %d | Actual: %d\n", i,
                        read_data);
            goto exit_condition;
        }
    }

    if (deallocate_page_addresses(mem_config.max_virtual_pages) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "deallocate_page_addresses of %d pages Failed\n",
                    mem_config.max_virtual_pages);
        goto exit_condition;
    }

    if (compare_reference_logs(log_filename) != SUCCESS) {
        log_console(LOG_CRITICAL, __FILE__, __FUNCTION__, __LINE__,
                    "Log compare failed! Did not match reference log\n");
        goto exit_condition;
    }

    ret_value = SUCCESS;

exit_condition:
    if (ret_value == FAILURE) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "TEST FAILED : %s\n", log_filename);
    } else {
        log_console(LOG_INFO, "", "", __LINE__, "TEST PASSED : %s\n",
                    log_filename);
    }
    return ret_value;
}

int test_data_access_pattern_clock(int memory_configuration)
{
    int ret_value = FAILURE;
    int i, j, address, page_no;
    uint64_t read_data, write_data;
    char log_filename[MAX_LOG_FILE_NAME_SIZE] = {};
    if (run_test_initilization_sequence(
            "test_access_pattern_clock", log_filename, BYTE_TYPE,
            memory_configuration, CLOCK_REPLACEMENT_POLICY) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "run_test_initilization_sequence Failed!\n");
        goto exit_condition;
    }

    log_console(LOG_INFO, "", "", __LINE__, "TEST START: %s\n", log_filename);

    if (allocate_page_addresses(mem_config.max_virtual_pages) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "allocate_page_addresses of %d pages Failed\n",
                    mem_config.max_virtual_pages);
        goto exit_condition;
    }

    //Fill the physical memory with page data. Each address will hold the value of the page no it belongs to.
    if (fill_memory(BYTE_TYPE, FILL_TYPE_PAGE_NO, PHYSICAL_MEMORY) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "Failed to fill physical memory\n");
        goto exit_condition;
    }

    //Read the entire physical memory in reverse order
    for (i = 0; i < mem_config.max_physical_pages; i++) {
        page_no = mem_config.max_physical_pages - 1 - i;
        address = page_address_container[page_no];
        for (j = 0; j < mem_config.max_page_entries; j++) {
            read_data = 0;
            if (pemmu_read_data(address, (void *) &read_data, BYTE_TYPE_SIZE) !=
                SUCCESS) {
                log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                            "pemmu_read_data failed\n");
                goto exit_condition;
            }
            if (read_data != page_no) {
                log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                            "Read Data Missmatch. Expected: %d | Actual: %d\n",
                            page_no, read_data);
                goto exit_condition;
            }
            address += BYTE_TYPE_SIZE;
        }
    }

    //Write one new page. The should cause the eviction of the very first page.
    address = page_address_container[mem_config.max_physical_pages];
    write_data = (uint32_t) mem_config.max_physical_pages + 1;
    if (pemmu_write_data(address, (void *) &write_data, BYTE_TYPE_SIZE) !=
        SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "pemmu_write_data failed\n");
        goto exit_condition;
    }

    //Read the remaining first half of the physical memory
    for (i = 1; i < mem_config.max_physical_pages / 2; i++) {
        address = page_address_container[i];
        read_data = 0;
        if (pemmu_read_data(address, (void *) &read_data, BYTE_TYPE_SIZE) !=
            SUCCESS) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "pemmu_read_data failed\n");
            goto exit_condition;
        }
    }

    //Write to (half of the max physical pages) new pages. This should cause the second half of the physical pages to be evicted
    for (i = 1; i <= mem_config.max_physical_pages / 2; i++) {
        address = page_address_container[mem_config.max_physical_pages + i];
        write_data = (uint32_t) mem_config.max_physical_pages + i;
        if (pemmu_write_data(address, (void *) &write_data, BYTE_TYPE_SIZE) !=
            SUCCESS) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "pemmu_write_data failed\n");
            goto exit_condition;
        }
    }

    //Read the first half of the physical memory (excluding the 0th page) and it should still be intact. No evictions.
    for (i = 1; i < mem_config.max_physical_pages / 2; i++) {
        address = page_address_container[i];
        if (pemmu_read_data(address, (void *) &read_data, BYTE_TYPE_SIZE) !=
            SUCCESS) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "pemmu_read_data failed\n");
            goto exit_condition;
        }
        if (read_data != i) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Read Data Missmatch. Expected: %d | Actual: %d\n", i,
                        read_data);
            goto exit_condition;
        }
    }

    if (deallocate_page_addresses(mem_config.max_virtual_pages) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "deallocate_page_addresses of %d pages Failed\n",
                    mem_config.max_virtual_pages);
        goto exit_condition;
    }

    if (compare_reference_logs(log_filename) != SUCCESS) {
        log_console(LOG_CRITICAL, __FILE__, __FUNCTION__, __LINE__,
                    "Log compare failed! Did not match reference log\n");
        goto exit_condition;
    }

    ret_value = SUCCESS;

exit_condition:
    if (ret_value == FAILURE) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "TEST FAILED : %s\n", log_filename);
    } else {
        log_console(LOG_INFO, "", "", __LINE__, "TEST PASSED : %s\n",
                    log_filename);
    }
    return ret_value;
}

int test_data_access_pattern_lru(int memory_configuration)
{
    int ret_value = FAILURE;
    int i, j, address, page_no;
    uint64_t read_data, write_data;
    char log_filename[MAX_LOG_FILE_NAME_SIZE] = {};
    if (run_test_initilization_sequence("test_access_pattern_lru", log_filename,
                                        BYTE_TYPE, memory_configuration,
                                        LRU_REPLACEMENT_POLICY) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "run_test_initilization_sequence Failed!\n");
        goto exit_condition;
    }

    log_console(LOG_INFO, "", "", __LINE__, "TEST START: %s\n", log_filename);

    if (allocate_page_addresses(mem_config.max_virtual_pages) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "allocate_page_addresses of %d pages Failed\n",
                    mem_config.max_virtual_pages);
        goto exit_condition;
    }

    //Fill the physical memory with page data. Each address will hold the value of the page no it belongs to.
    if (fill_memory(BYTE_TYPE, FILL_TYPE_PAGE_NO, PHYSICAL_MEMORY) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "Failed to fill physical memory\n");
        goto exit_condition;
    }

    //Read the entire physical memory in reverse order
    for (i = 0; i < mem_config.max_physical_pages; i++) {
        page_no = mem_config.max_physical_pages - 1 - i;
        address = page_address_container[page_no];
        for (j = 0; j < mem_config.max_page_entries; j++) {
            read_data = 0;
            if (pemmu_read_data(address, (void *) &read_data, BYTE_TYPE_SIZE) !=
                SUCCESS) {
                log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                            "pemmu_read_data failed\n");
                goto exit_condition;
            }
            if (read_data != page_no) {
                log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                            "Read Data Missmatch. Expected: %d | Actual: %d\n",
                            page_no, read_data);
                goto exit_condition;
            }
            address += BYTE_TYPE_SIZE;
        }
    }

    //Write to (half of the max physical pages) pages beyond the physical memory capacity.
    // This should cause the second half of the physical pages to be evicted
    for (i = 0; i < mem_config.max_physical_pages / 2; i++) {
        address = page_address_container[mem_config.max_physical_pages + i];
        write_data = mem_config.max_physical_pages + i;
        if (pemmu_write_data(address, (void *) &write_data, BYTE_TYPE_SIZE) !=
            SUCCESS) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "pemmu_write_data failed\n");
            goto exit_condition;
        }
    }

    //Read the first half of the physical memory and it should still be intact. No evictions
    for (i = 0; i < mem_config.max_physical_pages / 2; i++) {
        address = page_address_container[i];
        read_data = 0;
        if (pemmu_read_data(address, (void *) &read_data, BYTE_TYPE_SIZE) !=
            SUCCESS) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "pemmu_read_data failed\n");
            goto exit_condition;
        }
        if (read_data != i) {
            log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Read Data Missmatch. Expected: %d | Actual: %d\n", i,
                        read_data);
            goto exit_condition;
        }
    }

    if (deallocate_page_addresses(mem_config.max_virtual_pages) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "deallocate_page_addresses of %d pages Failed\n",
                    mem_config.max_virtual_pages);
        goto exit_condition;
    }

    if (compare_reference_logs(log_filename) != SUCCESS) {
        log_console(LOG_CRITICAL, __FILE__, __FUNCTION__, __LINE__,
                    "Log compare failed! Did not match reference log\n");
        goto exit_condition;
    }

    ret_value = SUCCESS;

exit_condition:
    if (ret_value == FAILURE) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "TEST FAILED : %s\n", log_filename);
    } else {
        log_console(LOG_INFO, "", "", __LINE__, "TEST PASSED : %s\n",
                    log_filename);
    }
    return ret_value;
}

int test_clean_dirty_eviction(int data_type, int memory_configuration,
                              int replacement_policy)
{
    int ret_value = FAILURE;
    // Set read_data to the highest size so that it covers all data types!
    uint64_t read_data = 0;
    int i, j, data_size;
    char log_filename[MAX_LOG_FILE_NAME_SIZE] = {};

    if (run_test_initilization_sequence(
            "test_clean_dirty_eviction", log_filename, data_type,
            memory_configuration, replacement_policy) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "run_test_initilization_sequence Failed!\n");
        goto exit_condition;
    }

    log_console(LOG_INFO, "", "", __LINE__, "TEST START: %s\n", log_filename);

    if (data_type == BYTE_TYPE) {
        data_size = BYTE_TYPE_SIZE;
    } else if (data_type == WORD_TYPE) {
        data_size = WORD_TYPE_SIZE;
    } else if (data_type == DWORD_TYPE) {
        data_size = DWORD_TYPE_SIZE;
    } else if (data_type == QWORD_TYPE) {
        data_size = QWORD_TYPE_SIZE;
    } else {
        log_console(LOG_CRITICAL, __FILE__, __FUNCTION__, __LINE__,
                    "Unsupported data type!\n");
        goto exit_condition;
    }

    if (allocate_page_addresses(mem_config.max_virtual_pages) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "allocate_page_addresses of %d pages Failed\n",
                    mem_config.max_virtual_pages);
        goto exit_condition;
    }

    log_test_framework("*** Filling Virtual Memory ***");
    //Fill the virtual memory. Physical memory now contains the second half of the virtual memory
    if (fill_memory(data_type, FILL_TYPE_UPCOUNTER, VIRTUAL_MEMORY) !=
        SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "Failed to fill virtual memory\n");
        goto exit_condition;
    }

    log_test_framework("*** Reading First Half of Virtual Memory ***");
    //Read the first half of the virtual memory. This should cause dirty evictions from the physical memory
    for (i = 0; i < mem_config.max_virtual_pages / 2; i++) {
        for (j = 0; j < mem_config.max_page_entries / data_size; j++) {
            if (pemmu_read_data(page_address_container[i], (void *) &read_data,
                                data_size) != SUCCESS) {
                goto exit_condition;
            }
        }
    }

    log_test_framework("*** Reading Second Half of Virtual Memory ***");
    //Read the second half of the virtual memory. This should cause clean evictions from the physical memory
    for (i = mem_config.max_virtual_pages / 2; i < mem_config.max_virtual_pages;
         i++) {
        for (j = 0; j < mem_config.max_page_entries / data_size; j++) {
            if (pemmu_read_data(page_address_container[i], (void *) &read_data,
                                data_size) != SUCCESS) {
                log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                            "pemmu_read_data failed\n");
                goto exit_condition;
            }
        }
    }

    if (deallocate_page_addresses(mem_config.max_virtual_pages) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "deallocate_page_addresses of %d pages Failed\n",
                    mem_config.max_virtual_pages);
        goto exit_condition;
    }

    if (compare_reference_logs(log_filename) != SUCCESS) {
        log_console(LOG_CRITICAL, __FILE__, __FUNCTION__, __LINE__,
                    "Log compare failed! Did not match reference log\n");
        goto exit_condition;
    }

    ret_value = SUCCESS;

exit_condition:
    if (ret_value == FAILURE) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "TEST FAILED : %s\n", log_filename);
    } else {
        log_console(LOG_INFO, "", "", __LINE__, "TEST PASSED : %s\n",
                    log_filename);
    }
    return ret_value;
}

/**
 *  Function : test_write_readback
 *
 *  @brief  Test function to fill the virtual memory by writing data and then reading them back after the
 *          write phase
 *
 *  @detail This test fills the virtual memory with data that can be reconstructed without saving it for comparison.
 *          After filling the data it reads it back and compares the read value to the expected value. Since the test
 *          fills the virtual memory appropriate page replacement policies will be invoked to evict physical pages
 *          once the physical memory is filled!
 *
 *  @return SUCCESS or FAILURE
 * */
int test_write_readback(int data_type, int memory_configuration,
                        int replacement_policy)
{
    int ret_value = FAILURE;
    char log_filename[MAX_LOG_FILE_NAME_SIZE] = {};

    if (run_test_initilization_sequence("test_write_readback", log_filename,
                                        data_type, memory_configuration,
                                        replacement_policy) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "run_test_initilization_sequence Failed!\n");
        goto exit_condition;
    }

    log_console(LOG_INFO, "", "", __LINE__, "TEST START: %s\n", log_filename);

    //Main subroutine of the test
    int i, j;
    int address;
    uint64_t data = 0;

    if (allocate_page_addresses(mem_config.max_virtual_pages) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "allocate_page_addresses of %d pages Failed\n",
                    mem_config.max_virtual_pages);
        goto exit_condition;
    }
    if (data_type == BYTE_TYPE) {
        uint8_t read_data = 0;
        for (i = 0; i < mem_config.max_virtual_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries / BYTE_TYPE_SIZE; j++) {
                data = j % UINT8_MAX;
                if (pemmu_write_data(address, (void *) &data, BYTE_TYPE_SIZE) !=
                    SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_write_data failed\n");
                    goto exit_condition;
                }
                address += BYTE_TYPE_SIZE;
            }
        }
        //Read the data from each page and compare it with the generated data
        for (i = 0; i < mem_config.max_virtual_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries; j++) {
                data = j % UINT8_MAX;
                if (pemmu_read_data(address, (void *) &read_data,
                                    BYTE_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_read_data failed\n");
                    goto exit_condition;
                }
                if (read_data != data) {
                    log_console(
                        LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Read Data Missmatch. Expected: %d | Actual: %d\n",
                        data, read_data);
                    goto exit_condition;
                }
                address += BYTE_TYPE_SIZE;
            }
        }
    } else if (data_type == WORD_TYPE) {
        uint16_t read_data = 0;
        uint16_t offset = UINT8_MAX;
        for (i = 0; i < mem_config.max_virtual_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries / WORD_TYPE_SIZE; j++) {
                data = (offset + j) % UINT16_MAX;
                if (pemmu_write_data(address, (void *) &data, WORD_TYPE_SIZE) !=
                    SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_write_data failed\n");
                    goto exit_condition;
                }
                address += WORD_TYPE_SIZE;
            }
        }
        //Read the data from each page and compare it with the generated data
        for (i = 0; i < mem_config.max_virtual_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries / WORD_TYPE_SIZE; j++) {
                data = (offset + j) % UINT16_MAX;
                if (pemmu_read_data(address, (void *) &read_data,
                                    WORD_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_read_data failed\n");
                    goto exit_condition;
                }
                if (read_data != data) {
                    log_console(
                        LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Read Data Missmatch. Expected: %d | Actual: %d\n",
                        data, read_data);
                    goto exit_condition;
                }
                address += WORD_TYPE_SIZE;
            }
        }
    } else if (data_type == DWORD_TYPE) {
        uint32_t read_data = 0;
        uint32_t offset = UINT16_MAX;
        for (i = 0; i < mem_config.max_virtual_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries / DWORD_TYPE_SIZE;
                 j++) {
                data = (offset + j) % UINT32_MAX;
                if (pemmu_write_data(address, (void *) &data,
                                     DWORD_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_write_data failed\n");
                    goto exit_condition;
                }
                address += DWORD_TYPE_SIZE;
            }
        }
        //Read the data from each page and compare it with the generated data
        for (i = 0; i < mem_config.max_virtual_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries / DWORD_TYPE_SIZE;
                 j++) {
                data = (offset + j) % UINT32_MAX;
                if (pemmu_read_data(address, (void *) &read_data,
                                    DWORD_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_read_data failed\n");
                    goto exit_condition;
                }
                if (read_data != data) {
                    log_console(
                        LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Read Data Missmatch. Expected: %d | Actual: %d\n",
                        data, read_data);
                    goto exit_condition;
                }
                address += DWORD_TYPE_SIZE;
            }
        }
    } else if (data_type == QWORD_TYPE) {
        uint64_t read_data = 0;
        uint64_t offset = UINT32_MAX;
        for (i = 0; i < mem_config.max_virtual_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries / QWORD_TYPE_SIZE;
                 j++) {
                data = (offset + j);
                if (pemmu_write_data(address, (void *) &data,
                                     QWORD_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_write_data failed\n");
                    goto exit_condition;
                }
                address += QWORD_TYPE_SIZE;
            }
        }
        //Read the data from each page and compare it with the generated data
        for (i = 0; i < mem_config.max_virtual_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries / QWORD_TYPE_SIZE;
                 j++) {
                data = (offset + j);
                if (pemmu_read_data(address, (void *) &read_data,
                                    QWORD_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_read_data failed\n");
                    goto exit_condition;
                }
                if (read_data != data) {
                    log_console(
                        LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Read Data Missmatch. Expected: %d | Actual: %d\n",
                        data, read_data);
                    goto exit_condition;
                }
                address += QWORD_TYPE_SIZE;
            }
        }
    } else {
        log_console(LOG_CRITICAL, __FILE__, __FUNCTION__, __LINE__,
                    "Unsupported data type!\n");
        goto exit_condition;
    }

    if (deallocate_page_addresses(mem_config.max_virtual_pages) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "deallocate_page_addresses of %d pages Failed\n",
                    mem_config.max_virtual_pages);
        goto exit_condition;
    }

    if (compare_reference_logs(log_filename) != SUCCESS) {
        log_console(LOG_CRITICAL, __FILE__, __FUNCTION__, __LINE__,
                    "Log compare failed! Did not match reference log\n");
        goto exit_condition;
    }

    ret_value = SUCCESS;

exit_condition:
    if (ret_value == FAILURE) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "TEST FAILED : %s\n", log_filename);
    } else {
        log_console(LOG_INFO, "", "", __LINE__, "TEST PASSED : %s\n",
                    log_filename);
    }
    return ret_value;
}

/**
 *  Function : test_fill_virtual_memory
 *
 *  @brief  Test function to fill the virtual memory and invoke replacement policies
 *
 *  @detail This test fills the virtual memory with some data and reads back the data to ensure
 *          a match! Since the test fills the virtual memory appropriate page replacement policies
 *          will be invoked to evict physical pages once the physical memory is filled!
 *
 *  @return SUCCESS or FAILURE
 * */
int test_fill_virtual_memory(int data_type, int memory_configuration,
                             int replacement_policy)
{
    int ret_value = FAILURE;
    char log_filename[MAX_LOG_FILE_NAME_SIZE] = {};

    if (run_test_initilization_sequence(
            "test_fill_virtual_memory", log_filename, data_type,
            memory_configuration, replacement_policy) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "run_test_initilization_sequence Failed!\n");
        goto exit_condition;
    }

    log_console(LOG_INFO, "", "", __LINE__, "TEST START: %s\n", log_filename);

    //Main subroutine of the test
    int i, j;
    int address;

    if (allocate_page_addresses(mem_config.max_virtual_pages) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "allocate_page_addresses of %d pages Failed\n",
                    mem_config.max_virtual_pages);
        goto exit_condition;
    }

    if (data_type == BYTE_TYPE) {
        uint8_t data;
        uint8_t read_data;
        for (i = 0; i < mem_config.max_virtual_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries; j++) {
                data = j % UINT8_MAX;
                if (pemmu_write_data(address, (void *) &data, BYTE_TYPE_SIZE) !=
                    SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_write_data failed\n");
                    goto exit_condition;
                }
                if (pemmu_read_data(address, (void *) &read_data,
                                    BYTE_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_read_data failed\n");
                    goto exit_condition;
                }
                if (data != read_data) {
                    log_console(
                        LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Read Data Missmatch. Expected: %d | Actual: %d\n",
                        data, read_data);
                    goto exit_condition;
                }
                address += BYTE_TYPE_SIZE;
            }
        }
    } else if (data_type == WORD_TYPE) {
        uint16_t data;
        uint16_t read_data;
        uint16_t offset = UINT8_MAX;
        for (i = 0; i < mem_config.max_virtual_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries / WORD_TYPE_SIZE; j++) {
                data = (offset + j) % UINT16_MAX;
                if (pemmu_write_data(address, (void *) &data, WORD_TYPE_SIZE) !=
                    SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_write_data failed\n");
                    goto exit_condition;
                }
                if (pemmu_read_data(address, (void *) &read_data,
                                    WORD_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_read_data failed\n");
                    goto exit_condition;
                }
                if (data != read_data) {
                    log_console(
                        LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Read Data Missmatch. Expected: %d | Actual: %d\n",
                        data, read_data);
                    goto exit_condition;
                }
                address += WORD_TYPE_SIZE;
            }
        }
    } else if (data_type == DWORD_TYPE) {
        uint32_t data;
        uint32_t read_data;
        uint32_t offset = UINT16_MAX;
        for (i = 0; i < mem_config.max_virtual_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries / DWORD_TYPE_SIZE;
                 j++) {
                data = (offset + j) % UINT32_MAX;
                if (pemmu_write_data(address, (void *) &data,
                                     DWORD_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_write_data failed\n");
                    goto exit_condition;
                }
                if (pemmu_read_data(address, (void *) &read_data,
                                    DWORD_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_read_data failed\n");
                    goto exit_condition;
                }
                if (data != read_data) {
                    log_console(
                        LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Read Data Missmatch. Expected: %d | Actual: %d\n",
                        data, read_data);
                    goto exit_condition;
                }
                address += DWORD_TYPE_SIZE;
            }
        }
    } else if (data_type == QWORD_TYPE) {
        uint64_t data;
        uint64_t read_data;
        uint64_t offset = UINT32_MAX;
        for (i = 0; i < mem_config.max_virtual_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries / QWORD_TYPE_SIZE;
                 j++) {
                data = (offset + j);
                if (pemmu_write_data(address, (void *) &data,
                                     QWORD_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_write_data failed\n");
                    goto exit_condition;
                }
                if (pemmu_read_data(address, (void *) &read_data,
                                    QWORD_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_read_data failed\n");
                    goto exit_condition;
                }
                if (data != read_data) {
                    log_console(
                        LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Read Data Missmatch. Expected: %d | Actual: %d\n",
                        data, read_data);
                    goto exit_condition;
                }
                address += QWORD_TYPE_SIZE;
            }
        }
    } else {
        log_console(LOG_CRITICAL, __FILE__, __FUNCTION__, __LINE__,
                    "Unsupported data type\n");
        goto exit_condition;
    }

    if (deallocate_page_addresses(mem_config.max_virtual_pages) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "deallocate_page_addresses of %d pages Failed\n",
                    mem_config.max_virtual_pages);
        goto exit_condition;
    }

    if (compare_reference_logs(log_filename) != SUCCESS) {
        log_console(LOG_CRITICAL, __FILE__, __FUNCTION__, __LINE__,
                    "Log compare failed! Did not match reference log\n");
        goto exit_condition;
    }

    ret_value = SUCCESS;

exit_condition:
    if (ret_value == FAILURE) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "TEST FAILED : %s\n", log_filename);
    } else {
        log_console(LOG_INFO, "", "", __LINE__, "TEST PASSED : %s\n",
                    log_filename);
    }
    return ret_value;
}

/**
 *  Function : test_fill_physical_memory
 *
 *  @brief  Test function to fill the physical memory.
 *
 *  @detail This test fills the physical memory with some data and reads back the data to ensure
 *          a match! Since the test only fills the physical memory no page replacement policy is
 *          invoked! Hence the replacement policy does not matter
 *
 *  @return SUCCESS or FAILURE
 * */
int test_fill_physical_memory(int data_type, int memory_configuration)
{
    int ret_value = FAILURE;
    char log_filename[MAX_LOG_FILE_NAME_SIZE] = {};

    //The replacement policy does not matter for the filling physical memory since it will never be invoked
    if (run_test_initilization_sequence("fill_physical_mem", log_filename,
                                        data_type, memory_configuration,
                                        FIFO_REPLACEMENT_POLICY) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "run_test_initilization_sequence Failed!\n");
        goto exit_condition;
    }

    log_console(LOG_INFO, "", "", __LINE__, "TEST START: %s\n", log_filename);

    int i, j, address;

    if (allocate_page_addresses(mem_config.max_physical_pages) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "allocate_page_addresses of %d pages Failed\n",
                    mem_config.max_physical_pages);
        goto exit_condition;
    }

    if (data_type == BYTE_TYPE) {
        uint8_t data = 0;
        uint8_t read_data;
        for (i = 0; i < mem_config.max_physical_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries; j++) {
                data = j % UINT8_MAX;
                if (pemmu_write_data(address, (void *) &data, BYTE_TYPE_SIZE) !=
                    SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_write_data failed\n");
                    goto exit_condition;
                }
                if (pemmu_read_data(address, (void *) &read_data,
                                    BYTE_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_read_data failed\n");
                    goto exit_condition;
                }
                if (data != read_data) {
                    log_console(
                        LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Read Data Missmatch. Expected: %d | Actual: %d\n",
                        data, read_data);
                    goto exit_condition;
                }
                address += BYTE_TYPE_SIZE;
            }
        }
    } else if (data_type == WORD_TYPE) {
        uint16_t data = 0;
        uint16_t read_data = 0;
        uint16_t offset = UINT8_MAX;
        for (i = 0; i < mem_config.max_physical_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries / WORD_TYPE_SIZE; j++) {
                data = (offset + j) % UINT16_MAX;
                if (pemmu_write_data(address, (void *) &data, WORD_TYPE_SIZE) !=
                    SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_write_data failed\n");
                    goto exit_condition;
                }
                if (pemmu_read_data(address, (void *) &read_data,
                                    WORD_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_read_data failed\n");
                    goto exit_condition;
                }
                if (data != read_data) {
                    log_console(
                        LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Read Data Missmatch. Expected: %d | Actual: %d\n",
                        data, read_data);
                    goto exit_condition;
                }
                address += WORD_TYPE_SIZE;
            }
        }
    } else if (data_type == DWORD_TYPE) {
        uint32_t data = 0;
        uint32_t read_data = 0;
        uint32_t offset = UINT16_MAX;
        for (i = 0; i < mem_config.max_physical_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries / DWORD_TYPE_SIZE;
                 j++) {
                data = (offset + j) % UINT32_MAX;
                if (pemmu_write_data(address, (void *) &data,
                                     DWORD_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_write_data failed\n");
                    goto exit_condition;
                }
                if (pemmu_read_data(address, (void *) &read_data,
                                    DWORD_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_read_data failed\n");
                    goto exit_condition;
                }
                if (data != read_data) {
                    log_console(
                        LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Read Data Missmatch. Expected: %d | Actual: %d\n",
                        data, read_data);
                    goto exit_condition;
                }
                address += DWORD_TYPE_SIZE;
            }
        }
    } else if (data_type == QWORD_TYPE) {
        uint64_t data = 0;
        uint64_t read_data = 0;
        uint64_t offset = UINT32_MAX;
        for (i = 0; i < mem_config.max_physical_pages; i++) {
            address = page_address_container[i];
            for (j = 0; j < mem_config.max_page_entries / QWORD_TYPE_SIZE;
                 j++) {
                data = (offset + j) % UINT64_MAX;
                if (pemmu_write_data(address, (void *) &data,
                                     QWORD_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_write_data failed\n");
                    goto exit_condition;
                }
                if (pemmu_read_data(address, (void *) &read_data,
                                    QWORD_TYPE_SIZE) != SUCCESS) {
                    log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                                "pemmu_read_data failed\n");
                    goto exit_condition;
                }
                if (data != read_data) {
                    log_console(
                        LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                        "Read Data Missmatch. Expected: %d | Actual: %d\n",
                        data, read_data);
                    goto exit_condition;
                }
                address += QWORD_TYPE_SIZE;
            }
        }
    } else {
        log_console(LOG_CRITICAL, __FILE__, __FUNCTION__, __LINE__,
                    "Unsupported data type!\n");
        goto exit_condition;
    }

    if (deallocate_page_addresses(mem_config.max_physical_pages) != SUCCESS) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "deallocate_page_addresses of %d pages Failed\n",
                    mem_config.max_physical_pages);
        goto exit_condition;
    }

    if (compare_reference_logs(log_filename) != SUCCESS) {
        log_console(LOG_CRITICAL, __FILE__, __FUNCTION__, __LINE__,
                    "Log compare failed! Did not match reference log\n");
        goto exit_condition;
    }

    ret_value = SUCCESS;

exit_condition:
    if (ret_value == FAILURE) {
        log_console(LOG_ERROR, __FILE__, __FUNCTION__, __LINE__,
                    "TEST FAILED : %s\n", log_filename);
    } else {
        log_console(LOG_INFO, "", "", __LINE__, "TEST PASSED : %s\n",
                    log_filename);
    }
    return ret_value;
}
